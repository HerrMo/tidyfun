% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fbase-def.R, R/feval-def.R,
%   R/fvector-conversion.R
\name{fbase}
\alias{fbase}
\alias{fbase.data.frame}
\alias{fbase.matrix}
\alias{fbase.numeric}
\alias{fbase.list}
\alias{fbase.feval}
\alias{fbase.fbase}
\alias{feval.numeric}
\alias{as.fbase}
\alias{as.fbase.matrix}
\alias{as.fbase.data.frame}
\alias{as.fbase.list}
\alias{as.fbase.feval}
\alias{as.data.frame.fbase}
\alias{as.matrix.fbase}
\title{Constructors for (smoothed) functional data in basis representation}
\usage{
fbase(data, ...)

\method{fbase}{data.frame}(data, id = 1, argvals = 2, value = 3,
  domain = NULL, penalized = TRUE, signif = 4, ...)

\method{fbase}{matrix}(data, argvals = NULL, domain = NULL,
  penalized = TRUE, signif = 4, ...)

\method{fbase}{numeric}(data, argvals = NULL, domain = NULL,
  penalized = TRUE, signif = 4, ...)

\method{fbase}{list}(data, argvals = NULL, domain = NULL,
  penalized = TRUE, signif = 4, ...)

\method{fbase}{feval}(data, argvals = NULL, domain = NULL,
  penalized = TRUE, signif = 4, ...)

\method{fbase}{fbase}(data, argvals = NULL, domain = NULL,
  penalized = TRUE, signif = 4, ...)

\method{feval}{numeric}(data, argvals = NULL, domain = NULL,
  evaluator = approx_linear, signif = 4, ...)

as.fbase(data, ...)

\method{as.fbase}{matrix}(data, argvals = NULL, domain = NULL,
  penalized = TRUE, signif = 4, ...)

\method{as.fbase}{data.frame}(data, id = 1, argvals = 2, value = 3,
  domain = NULL, penalized = TRUE, signif = 4, ...)

\method{as.fbase}{list}(data, argvals = NULL, domain = NULL,
  penalized = TRUE, signif = 4, ...)

\method{as.fbase}{feval}(data, argvals = NULL, domain = NULL,
  penalized = TRUE, signif = 4, ...)

\method{as.data.frame}{fbase}(x, rownames = NULL, optional = FALSE,
  argvals = NULL, ...)

\method{as.matrix}{fbase}(x, argvals = NULL, ...)
}
\arguments{
\item{data}{a \code{matrix}, \code{data.frame} or \code{list} of suitable shape, or another \code{fvector}-object.}

\item{...}{arguments to the calls to \code{\link[mgcv:s]{mgcv::s()}} setting up the basis and
\code{\link[mgcv:magic]{mgcv::magic()}} (if \code{penalized} is TRUE). If not user-specified here,
\code{tidyfun} uses \code{k=15} cubic regression spline basis functions (i.e., \code{bs = "cr"}) by default, but at least how many basis functions \code{k} the spline
basis should have probably needs to be set manually ....}

\item{id}{The name/number of the column defining which data belong to which function.}

\item{argvals}{\code{numeric}, or list of \code{numeric}s. The evaluation grid. See Details.}

\item{value}{The name/number of the column containing the function evaluations.}

\item{domain}{range of the \code{argvals}.}

\item{penalized}{should the coefficients of the basis representation be estimated
via \code{\link[mgcv:magic]{mgcv::magic()}} (default) or ordinary least squares.}

\item{signif}{significant digits of the "resolution" of the evaluation grid.  See details.}

\item{evaluator}{a function accepting arguments \code{x, argvals, evaluations}. See details.}

\item{x}{an \code{fbase} object}

\item{rownames}{not used}

\item{optional}{not used}
}
\value{
an \code{fbase}-object (or a \code{data.frame}/\code{matrix} for the conversion functions, obviously.)
}
\description{
Various constructor and conversion methods.
}
\details{
\code{fbase} takes the data it is supplied with and tries to represent them as linear
combinations of a set of common spline basis functions identical for all
observations with coefficient vectors estimated for each observation. The
basis used is set up via a call to \code{\link[mgcv:s]{mgcv::s()}} and all the spline bases
discussed in \link[mgcv:smooth.terms]{mgcv::smooth.terms} are available, in principle. Depending on
the value of the \code{penalized}-flag, the coefficient vectors for each
observation are then estimated via fitting a small GAM for each observation
via \code{\link[mgcv:magic]{mgcv::magic()}} or via simple ordinary least squares.

After the "smoothed" representation is computed, the amount of smoothing that
was performed is reported in terms of the "percentage of variance preserved",
which is the variance of the smoothed function values divided by the variance
of the original values. The \code{...} arguments supplies arguments to both the
spline basis set up (via \code{\link[mgcv:s]{mgcv::s()}}) and the estimation (via
\code{\link[mgcv:magic]{mgcv::magic()}}), most important are probably how many basis functions \code{k}
the spline basis should have and/or manually setting the smoothing parameter
\code{sp}. The latter can also be used to enforce the same amount of penalization
for all functional observations.
}
