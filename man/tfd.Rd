% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/convert.R, R/tfd-class.R
\name{as.tfd}
\alias{as.tfd}
\alias{as.tfd_irreg}
\alias{as.data.frame.tfd}
\alias{as.matrix.tfd}
\alias{tfd}
\alias{tfd.matrix}
\alias{tfd.numeric}
\alias{tfd.data.frame}
\alias{tfd.list}
\alias{tfd.tf}
\title{Constructors for functional data evaluated on grids of argument values}
\usage{
as.tfd(data, ...)

as.tfd_irreg(data, signif = NULL, ...)

\method{as.data.frame}{tfd}(x, row.names = NULL, optional = FALSE,
  argvals = NULL, interpolate = FALSE, ...)

\method{as.matrix}{tfd}(x, argvals = NULL, interpolate = FALSE, ...)

tfd(data, ...)

\method{tfd}{matrix}(data, argvals = NULL, domain = NULL,
  evaluator = approx_linear, signif = 4, ...)

\method{tfd}{numeric}(data, argvals = NULL, domain = NULL,
  evaluator = approx_linear, signif = 4, ...)

\method{tfd}{data.frame}(data, id = 1, argvals = 2, value = 3,
  domain = NULL, evaluator = approx_linear, signif = 4, ...)

\method{tfd}{list}(data, argvals = NULL, domain = NULL,
  evaluator = approx_linear, signif = 4, ...)

\method{tfd}{tf}(data, argvals = NULL, domain = NULL,
  evaluator = approx_linear, signif = 4, ...)
}
\arguments{
\item{data}{a \code{matrix}, \code{data.frame} or \code{list} of suitable shape, or another \code{tf}-object.}

\item{...}{not used in \code{tfd}, except for \code{tfd.tf} -- specify \code{argvals} and \code{Ã¬nterpolate = TRUE} to
turn an irregular \code{tfd} into a regular one, see examples.}

\item{signif}{significant digits of the "resolution" of the evaluation grid.  See details.}

\item{x}{an \code{tfd} object}

\item{row.names}{not used}

\item{optional}{not used}

\item{argvals}{\code{numeric}, or list of \code{numeric}s. The evaluation grid. See Details.
For the \code{data.frame}-methods: the name/number of the column defining the evaluation grid.}

\item{interpolate}{should functions be evaluated (i.e., inter-/extrapolated)
for \code{argvals} for which no original data is available? Only relevant for
\code{tfd}, defaults to TRUE.}

\item{domain}{range of the \code{argvals}.}

\item{evaluator}{a function accepting arguments \code{x, argvals, evaluations}. See details.}

\item{id}{The name/number of the column defining which data belong to which function.}

\item{value}{The name/number of the column containing the function evaluations.}
}
\value{
an \code{tfd}-object (or a \code{data.frame}/\code{matrix} for the conversion functions, obviously.)
}
\description{
Various constructor and conversion methods.

\code{tfd.list} accepts a list of vectors of identical lengths
containing evaluations or a list of 2-column matrices/data.frames with
\code{argvals} in the first and evaluations in the second column
}
\details{
\strong{\code{evaluator}}: must be a \code{function(x, argvals, evaluations)} that returns
the function's (approximated/interpolated) values at locations \code{x} based on
the \code{evaluations} available at locations \code{argvals}.
Available \code{evaluator}-functions:
\itemize{
\item \code{approx_linear} for linear interpolation without extrapolation (i.e.,
\code{\link[zoo:na.approx]{zoo::na.approx()}} with \code{na.rm = FALSE})  -- this is the default,
\item \code{approx_spline} for cubic spline interpolation, (i.e., \code{\link[zoo:na.spline]{zoo::na.spline()}}
with \code{na.rm = FALSE}),
\item \code{approx_fill_extend} for linear interpolation and constant extrapolation
(i.e., \code{\link[zoo:na.fill]{zoo::na.fill()}} with \code{fill = "extend"})
\item \code{approx_locf} for "last observation carried forward"  (i.e.,
\code{\link[zoo:na.locf]{zoo::na.locf()}} with \code{na.rm = FALSE} and
\item \code{approx_nocb} for "next observation carried backward" (i.e.,
\code{\link[zoo:na.locf]{zoo::na.locf()}} with \code{na.rm = FALSE, fromLast = TRUE}).
}

See \code{tidyfun:::zoo_wrapper} and \code{tidyfun:::approx_linear}, which is simply
\code{zoo_wrapper(zoo::na.approx, na.rm = FALSE)}, for examples of implementations of
this.

\strong{\code{signif}}: \code{argvals} that are equivalent to this significant digit are
treated as identical. E.g., if an evaluation of f(t) is available at t=1 and a function
value is requested at t = 1.001, f(1) will be returned if \code{signif} < 4.
}
\examples{
#turn irregular to regular tfd
#TODO: add extra function/verb for this
(f <- c(rgp(1, argvals = seq(0,1,l=11)), rgp(1, argvals = seq(0,1,l=21))))
tfd(f, interpolate = TRUE, argvals = seq(0,1,l=21))
}
