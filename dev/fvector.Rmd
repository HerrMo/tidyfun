---
title: "<ftable> and <fvector> - new data structures for tidy functional data"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Definition: `fvector`

`fvector` defines a new S3 class to represent functional data. 

Internallly, an `fvector` is 

- a list of (something like) function values 
- with attributes for metainformation like ranges or bases

so that functional data can be included in tidy `data.frames` as list columns^[similar in construction to the `sfc`-columns  that `sf` defines].

We'll have at least 3 subclasses for different data settings:

- functional data as function evaluations: `feval`
    - on a common grid of argument values: `feval_reg`
    - on observation-specific grids of argument values: `feval_irreg`
- functional data in basis function representation: `fbasis`

## Definition: `feval`

```{r feval-def}
library(purrr)
library(dplyr)

feval <- function(data, ...) UseMethod("feval")

feval.matrix <- function(data, argvals = NULL, regular = NULL, ...) {
  stopifnot(is.numeric(data))
  
  argvals <- find_argvals(data, argvals) # either arg or numeric colnames or 1:ncol
  datalist <- split(data, rownames(data) %||% seq_len(dim(data)[1]))
  
  regular <- regular %||% !any(is.na(data))
  if (!regular) {
    argvals <- map2(datalist, argvals, ~ .y[!is.na(.x)])
    datalist <- map(datalist, ~ .x[!is.na(.x)])
    class <- "feval_irreg"
  } else {
    class <- "feval_reg"
  }
  structure(datalist, 
    argvals = argvals, 
    class = c(class, "feval", "fvector"))
}
# use first 3 columns of data for function information
feval.data.frame <- function(data, id = 1, argvals = 2, value = 3, ...) {
  stopifnot(ncol(data) >= 3, is.numeric(data[[argvals]]), 
    is.numeric(data[[value]]))
  datalist <- split(data[[value]], data[[id]])
  argvals <- split(data[[argvals]], data[[id]])
  if (sum(duplicated(argvals)) == length(argvals) - 1) {
    argvals <- unname(argvals[1])
    class <- "feval_reg"
  } else class <- "feval_irreg"
  structure(datalist, 
    argvals = argvals, 
    class = c(class, "feval", "fvector"))
}

argvals <- function(x) attr(x, "argvals")
find_argvals <- function(data, argvals) {
  if (is.null(argvals)) {
    argvals <- as.numeric(dimnames(data)[[2]])
  } 
  if (!length(argvals)) argvals <- seq_len(dim(data)[2])
  stopifnot(length(argvals)  == dim(data)[2], 
    is.numeric(argvals), all(!is.na(argvals)))
  list(argvals)
}
```

```{r feval-conversion}
# conversions to/from data.frame, matrix
as.feval <- function(data, ...) UseMethod("as.feval")
as.feval.matrix  <- function(data, argvals = NULL, regular = NULL, ...) {
  feval(data, argvals, regular, ...)
}
as.feval.data.frame <- function(data, id = 1, argvals = 2, value = 3, ...) {
  feval(data, id, argvals, value, ...)
}

as.data.frame.feval  <- function(x) {
  bind_rows(pmap(list(id = as.list(seq_along(x)), argvals = argvals(x),  value = x), 
    ~ bind_cols(id = rep(..1, length(..2)), argvals = ..2, value = ..3)))
}
```

```{r sandbox}
n <- 5
grid <-  seq(0, 1, l = 11)
mat_reg <- t(replicate(n, dbeta(grid, runif(1, 2, 7), runif(1, 3, 12))))
colnames(mat_reg) <- grid
mat_irreg <- mat_reg; mat_irreg[sample(1:length(mat_reg), length(mat_reg)/3)] <- NA

f_reg <- feval(mat_reg)
str(f_reg, 1)
str(argvals(f_reg), 1)

f_irreg <- feval(mat_irreg)
str(f_irreg, 1)
str(argvals(f_irreg), 1)

as.data.frame(f_reg)
as.data.frame(f_irreg)
all.equal(as.feval(as.data.frame(f_reg)), f_reg)
all.equal(as.feval(as.data.frame(f_irreg)), f_irreg)
```

*TODO: additional attributes "domain", "range"; validation methods*
*TODO: converters for fdata, fd*
*TODO: multivariate functions, multidimensional argvals*

```{r feval-methods, eval = FALSE}
print
summary
`[`
`[<-`  
plot
length
deriv
mean
quantile
var
sd
cov
cor
max
min

# new generics:
integrate

```
