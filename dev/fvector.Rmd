---
title: "<ftable> and <fvector> - new data structures for tidy functional data"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Definition: `fvector`

`fvector` is a new `S3` class for representing functional data. 

Internallly, an `fvector` is 

- a list of (something like) function values 
- with attributes for metainformation like ranges or bases

so that functional data can be included in tidy `data.frames` as list columns^[similar in construction to the `sfc`-columns  that `sf` defines].

We'll have at least 3 subclasses for different data settings:

- functional data as function evaluations: `feval`
    - on a common grid of argument values: `feval_reg`
    - on observation-specific grids of argument values: `feval_irreg`
- functional data in basis function representation: `fbasis`

## Definition: `feval`

```{r feval-def}
library(purrr)
library(dplyr)

feval <- function(data, ...) UseMethod("feval")

new_feval <- function(argvals, datalist, regular, domain, range) {
  if (!regular) {
    argvals <- map2(datalist, argvals, ~ .y[!is.na(.x)])
    datalist <- map(datalist, ~ .x[!is.na(.x)])
    class <- "feval_irreg"
  } 
  ret <- map2(argvals, datalist, ~ make_fapprox(.x, .y))
  if (regular) {
    argval_env <- new.env(); argval_env$argvals <- argvals[[1]]
    ret <- map(ret, function(f) {
      rm("argvals", envir = environment(f))
      parent.env(environment(f)) <- argval_env
      f
    })
    class <- "feval_reg"
  }
  names(ret) <- names(datalist) %||% seq_along(ret)
  structure(ret, 
    domain = domain,
    range = range,
    class = c(class, "feval", "fvector"))
}

feval.matrix <- function(data, argvals = NULL, regular = NULL, domain = NULL, 
    range = NULL, ...) {
  stopifnot(is.numeric(data))
  
  argvals <- find_argvals(data, argvals) # either arg or numeric colnames or 1:ncol
  datalist <- split(data, rownames(data) %||% seq_len(dim(data)[1]))
  
  domain <- domain %||% range(argvals)
  range <- range %||% range(data, na.rm = TRUE)
  regular <- regular %||% !any(is.na(data))
  new_feval(argvals, datalist, regular, domain, range)
}
# use first 3 columns of data for function information
feval.data.frame <- function(data, id = 1, argvals = 2, value = 3, domain = NULL, 
    range = NULL, ...) {
  stopifnot(ncol(data) >= 3, is.numeric(data[[argvals]]), 
    is.numeric(data[[value]]))
  datalist <- split(data[[value]], data[[id]])
  argvals <- split(data[[argvals]], data[[id]])
  domain <- domain %||% range(argvals)
  range <- range %||% range(datalist, na.rm = TRUE)
  regular <- sum(duplicated(argvals)) == length(argvals) - 1
  new_feval(argvals, datalist, regular, domain, range)
}

argvals <- function(x) UseMethod("argvals")
argvals.feval_irreg <- function(x) map(x, ~ environment(.x)$argvals)
argvals.feval_reg <- function(x) parent.env(environment(x[[1]]))$argvals

domain <- function(x) attr(x, "domain")
range.fvector <- function(x) attr(x, "range")

find_argvals <- function(data, argvals) {
  if (is.null(argvals)) {
    argvals <- as.numeric(dimnames(data)[[2]])
  } 
  if (!length(argvals)) argvals <- seq_len(dim(data)[2])
  stopifnot(length(argvals)  == dim(data)[2], 
    is.numeric(argvals), all(!is.na(argvals)))
  list(argvals)
}
make_fapprox <- function(argvals, data) {
  function(v) {
    Hmisc::approxExtrap(x = argvals, y = data, xout = v)$y
  }
}

```

```{r feval-conversion}
# conversions to/from data.frame, matrix
as.feval <- function(data, ...) UseMethod("as.feval")
as.feval.matrix  <- function(data, argvals = NULL, regular = NULL, domain = NULL, 
    range = NULL, ...) {
  feval(data, argvals, regular, domain, range, ...)
}
as.feval.data.frame <- function(data, id = 1, argvals = 2, value = 3, domain = NULL, 
    range = NULL, ...) {
  feval(data, id, argvals, value, domain, range, ...)
}

as.data.frame.feval <- function(x) {
  argvals <- argvals(x)
  if (inherits(x, "feval_reg")) argvals <- list(argvals)
  tmp <- list(id = names(x), argvals = argvals,  flist = x)
  bind_rows(pmap(tmp, ~ bind_cols(id = rep(..1, length(..2)),  argvals = ..2, 
    value = do.call(..3, list(..2)))))
}
as.matrix.feval_reg <- function(x) {
  argvals <- argvals(x)
  ret <- vapply(x, function(f) environment(f)$data, numeric(length(argvals)))
  dimnames(ret) <- list(argvals, names(x))
  structure(t(ret), argvals = argvals)
}
as.matrix.feval_irreg <- function(x) {
  argvals <- argvals(x)
  grid <- sort(unique(unlist(argvals)))
  ret <- pmap(list(x, argvals, grid), 
  dimnames(ret) <- list(argvals, names(x))
  structure(t(ret), argvals = argvals)
}
if (inherits(x, "feval_irreg")) argvals <- sort(unique(unlist(argvals)))
  
```

```{r sandbox}
n <- 5
grid <-  seq(0, 1, l = 11)
mat_reg <- t(replicate(n, dbeta(grid, runif(1, 2, 7), runif(1, 3, 12))))
colnames(mat_reg) <- grid
mat_irreg <- mat_reg; mat_irreg[sample(1:length(mat_reg), length(mat_reg)/3)] <- NA

f_reg <- feval(mat_reg)
str(f_reg, 1)
str(argvals(f_reg), 1)

f_irreg <- feval(mat_irreg)
str(f_irreg, 1)
str(argvals(f_irreg), 1)

as.data.frame(f_reg)
as.data.frame(f_irreg)
all.equal(as.feval(as.data.frame(f_reg)), f_reg)
all.equal(as.feval(as.data.frame(f_irreg)), f_irreg)
```

*TODO: validation methods*
*TODO: converters for fdata, fd*
*TODO: multivariate functions, multidimensional argvals*

```{r feval-methods, eval = FALSE}
print.feval <- function(x) {
  cat(paste0("feval[",length(x),"] on (", domain(x)[1], ",", domain(x)[2], ")\n"))
  cat("evaluated for:\n")
  print(argvals(x))
  invisible(x)
}
#summary #define Arith-methods first.... 
# c.feval_reg #???
`[.feval` <- function(x, i, j, interpolate = TRUE) {
  browser()
  if (missing(j)) {
    ret <- unclass(x)[i]
    domain(ret) <- domain(x); range(ret) <- range(x); class(ret) <- class(x)
    return(ret)
  }
  if (!interpolate) {
    in_argvals <- map2(list(j), argvals(x), ~ which(.x %in% .y))
    if(any(!in_argvals)) warning("<j> not part of argvals")
  }
  # check j in range  
  }
}
#`[.feval_irreg`
#`[<-`  
#plot
#length
#deriv
#mean
#quantile
#var
#sd
#cov
#cor
#max
#min

# new generics:
integrate

```
