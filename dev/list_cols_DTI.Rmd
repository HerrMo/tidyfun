---
title: "List columns with the DTI data"
output: html_document
---

```{r}
knitr::opts_chunk$set(
	echo = TRUE,
	warning = FALSE,
  fig.width = 6,
  fig.asp = .6,
  out.width = "90%"
)

library(tidyverse)

library(refund)
library(vbvs.concurrent)

library(checkmate)

theme_set(theme_bw())
theme_update(legend.position = "bottom")
```

# Nesting DTI data

Code below converts `refund::DTI` to a nested df -- `rcst` and `cca` are converted from matrix to lists. 

```{r}
data(DTI)

fmatrix2nested <- function(X, argvals = NULL) {
  
  if (!is.null(argvals)) {
    assert_numeric(argvals, any.missing = FALSE)
    assert_matrix(X, mode = "numeric", ncols = length(argvals))
  } else {
    assert_matrix(X, mode = "numeric")
    argvals = seq(0, 1, length = dim(X)[2])
  }
  
  apply(X, 1, function(x) {
    na.omit(tibble(index = argvals, value = x))
  })
}

nest_col = function(col){
  
  if (class(col) != "matrix") {
    col
  } else {
    fmatrix2nested(col)
  }
  
}

system.time(DTI_nested <- map_df(DTI, ~nest_col(.x)))
```

Time taken to convert from matrix to list isn't too bad. (Notice I changed the names in the df according to [this conversation](https://github.com/refunders/refund/issues/64))

Quick check on relative sizes shows that matrix format is more efficient in this case.

```{r, error = TRUE}
unclass(object.size(DTI_nested) / object.size(DTI))
```

But list columns are helpful because they work with the tidyverse.

```{r, error = TRUE}
filter(DTI, visit == 1)
filter(DTI_nested, visit == 1)
```

# Using list columns

It's nice to have a tidyverse-friendly dataset!

```{r}
DTI_nested %>%
  filter(visit == 1) %>%
  select(ID, case, sex, cca) %>%
  unnest()
```

Note that we have to keep the `id` variable so that subjects can be distinguished after unnesting.

Using list columns will require frequent unnesting / renesting. Could be a steep learning curve for users ...

Here's a spaghetti plot.

```{r}
DTI_nested %>%
  filter(visit == 1) %>%
  select(ID, case, sex, cca) %>%
  unnest() %>%
  ggplot(aes(x = index, y = value, group = ID)) + geom_path()
```

You can smooth each curve and extract basis coefs, if you want:

```{r}
smooth_function = function(tibble) {
  basis = splines::bs(tibble$index, df = 5, intercept = TRUE)
  
  fit = lm(value ~ 0 + basis, data = tibble)
  broom::tidy(fit) %>%
    select(term, estimate)
}

DTI_nested %>%
  filter(visit == 1) %>%
  select(ID, case, sex, rcst) %>%
  mutate(spline_coefs = map(rcst, ~smooth_function(.x))) %>%
  select(-rcst) %>%
  unnest()
```

Here, the list column is helpful -- it gives you something to `map` over. Without that structure you'd have to `nest` first. 

Lastly, I'm passing an unnested df into `bayes_fosr`. The function expects data in the form of a dataframe with set columns, and might be an interface we want to use in other cases. Note the code itself is actually kind of gross because I had to trick this function into doing something it's not really intended to do, and my code wasn't great ...

```{r}
vbvs_fit = 
  DTI_nested %>%
  filter(visit == 1) %>%
  select(ID, case, sex, rcst) %>%
  unnest() %>%
  mutate(one = 1) %>%
  rename(time = index) %>%
  vbvs_concurrent(value ~ one | time, id.var = "ID", standardized = TRUE, data = .)
```

# Some thoughts

I think we can plan on most statisticians learning the tidyverse over the next five years or so (at least the ones who are actively coding things), so a data-frame-centric approach makes sense. We can also plan on this being a useful framework (e.g. people will know how to filter and select).

I also like list columns for general functional data, although a plain data frame with `index` and `value` columns would maybe get us (and users) a pretty fair distance. 

A couple of options are:

  * go all in on list columns, and spend time writing the supporting software, documentation, and examples 
  * go half-in on list columns and half-in on tidy dataframes; the product then might be a manifesto about tidy data in the context of functional data

Deciding between these may depend on the scope of our ambition. For `fpca.zz` functions (which focus on decomposing individual functions) it probably (?) wouldn't be too bad to allow either tidy dfs or list columns. Supporting both options everywhere downstream might be a huge pain...


