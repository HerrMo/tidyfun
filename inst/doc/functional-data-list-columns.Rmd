---
title: "`tidyfun`: List columns for functional data"
output: html_document
---

```{r}
library(magrittr)
library(tibble)
library(tidyr)
library(dplyr)
library(purrr)
library(ggplot2)
library(checkmate)
library(profvis)
```

# Data Settings

### Regular functions on a grid

Currently saved as matrix columns (in `refund`, at least).

**+**: 

- easy access via [,]
- easy arithmetic, can use `apply`, etc.

**-**: 

- matrix columns incompatible with tidyverse
- argument values not part of matrix (have to be saved as colnames / float around in a separate vector)

Proposed: long format for data with a single functional entry

**+**:

- adheres to tidy data principle --> compatible with `tidyverse`
- argument values saved as separate column
- works just the same for irregular data

**-**: 

- hides functional nature
- inefficient for large data (repeat all other covariates for *every* measurement of the function), especially if done with more than one function...


Proposed: list columns / nested tibbles for data with multiple functional entries

**+**:

- kinda adheres to tidy data principle, mostly compatible with `tidyverse`
- at least superficially this should work just the same for irregular data

**-**: 

- list columns / nested tables are complicated, users need to know `purrr`, `broom` etc.
- no direct plots, summaries etc, always needs list-processing
    - inefficient storage: will prob. mean argument values have to be saved in the list entry *for each observation* instead of in one global location.


### Irregular functions

`refund` functions currently expect special data.frames  with columns `.obs`, `.index`, `.value`. Such tables could (easily) be transformed into or reshaped from list columns or nested tibbles. 

## List column/nested tibble implementation


### Evaluation criteria:

- memory consumption
- ease of common operations:
    - scaling/centering
    - subsetting argument value ranges 
    - evaluating/interpolating on new argument values (for conversion to matrices/data.frames, plotting)
    - ... what else ... ?

### Options for representation:

1. use nesting: functions are sub-tables with columns `.arg`, `.value`^[better than `.index, .value` going forward?] 
    - **+** extensible to image-like data (`.arg1`, `.arg2`, ...) as well as multivariate functions (`.value1`, `.value2`, ...)
    - **+** solid tidyverse foundation
    - (**-**) memory inefficient for gridded data (but see below, also not actually worse than other options)
2. functions as list columns of `funData` instances
1. functions as list columns of `ftibble` instances (class to be written, see below)

(functions as list columns containing vectors for gridded functions and
  matrices with `.arg`, `.value` for irregular also possible, but weird. )

### Desirable features / Nice-to-have:

- allow function objects in basis representation
- if list column of "functional data" class-objects is used could re
- (special list-column types with metainformation like argument values etc saved for the column instead of each entry) ... would need additional code in `dplyr` etc for "homogeneous" list columns. not likely to happen, probably...

```{r}
make_X <- function(n = 20, ngrid = 50) {
  argvals <- seq(0, 1, length = ngrid)
  funs <- t(replicate(n, rnorm(1) + dbeta(argvals, runif(1, 2, 7), runif(1, 3, 8))))
  list(argvals = argvals, funs = funs)
}
set.seed(1313)
X <- make_X(n = 100, ngrid = 80)
argvals <- X$argvals; X <- X$funs
```


### Representation using nested `tibble`s:

**Conversion/Construction from/to matrix:**

```{r}
fmatrix2nested <- function(X, argvals) {
  assert_numeric(argvals, any.missing = FALSE)
  assert_matrix(X, mode = "numeric", ncols = length(argvals))
  apply(X, 1, function(x) {
    na.omit(tibble(.arg = argvals, .value = x))
  })
}
nested2fmatrix <- function(data, fcolumn) {
  X_list <- select(data, !!enquo(fcolumn))
  ##TODO: check proper lengths, names etc....
  list(X = do.call(rbind, map(X_list[[1]], ~.$.value)),
    argvals = X_list[[1]][[1]]$.arg)
}

X_list <- fmatrix2nested(X, argvals)
nested_df <- data_frame(
  id = 1:length(X_list), 
  X = X_list)
```

**Relative memory size of objects:**

```{r, fig=TRUE, cache= TRUE}
memfactor_nested <- Vectorize(function(N, ngrid) {
  X <- make_X(N, ngrid)
  X_list <- fmatrix2nested(X$funs, X$argvals)
  unclass(object.size(X_list)/object.size(X))
}) 
memory <- expand.grid(N = c(10, 50, 200), 
  ngrid = c(10, 20, 50, 100, 500, 1e3, 2e3)) %>% 
  mutate(memory_factor = memfactor_nested(N, ngrid))
print(ggplot(memory, aes(x = ngrid, y = log(memory_factor, 2), col = factor(N), group = N)) +
  geom_line())
```
--> wasteful only for small data sets where it does not matter, 
seems to converge to ~2x the memory for larger data sets (...why...?!?)

**Time for transforming back & forth:**

```{r, fig=TRUE, cache= TRUE}
timed_trans <- Vectorize( function(N, ngrid) {
  X <- make_X(N, ngrid)
  nest <- unname(system.time(
    nested <- tibble(X = fmatrix2nested(X$funs, X$argvals))
    )["elapsed"])
 unnest  <- unname(system.time(nested2fmatrix(nested, X))["elapsed"])
 return(tibble(op = c("nest", "unnest"), time = c(nest, unnest)))
}, SIMPLIFY = FALSE)

set.seed(1212)
transtimes <- expand.grid(N = c(50, 100, 200, 500), 
  ngrid = c(10, 20, 100, 500)) %>% 
  mutate(times = timed_trans(N, ngrid)) %>% unnest
ggplot(transtimes, 
  aes(x = N, y = time, group = ngrid, col = factor(ngrid))) +
  facet_wrap(~op, scales = "free") +
  geom_line()
```

- creating a list column (nesting) 2 orders of magnitude slower than unnesting one  (seems ok for the dataset size (~ couple 100s of observations) we usually deal with) 
- scaling behavior: independent of ngrid, linear in N with slope 1 (...duh)

**Common operations:**

*Scaling/centering/arithmetic:*
```{r}
arg_apply <- function(FUN, data, fcolumn, ...) {
  unnest(data, !!enquo(fcolumn)) %>% group_by(.arg) %>% 
  summarise(.value = FUN(.value, ...))
}
fcenter <- function(X) {
  m <- colMeans(X, na.rm = TRUE)
  sd <- apply(X, 2, sd, na.rm = TRUE)
  t((t(X) - m)/sd)
}

profvis({
  # via map (also works for irregular data)
  fmean <- arg_apply(mean, nested_df, X)
  fsd <- arg_apply(sd, nested_df, X)
  nested_df %<>% mutate(Xc = map(X, ~ tibble(.arg = .$.arg, .value = (.$.value- fmean$.value)/fsd$.value)))

  # unnest - matrix ops - nest
  nested_df %<>% mutate(Xc = fmatrix2nested(fcenter(nested2fmatrix(nested_df, X)$X), argvals))
  
  # sanity check
  all.equal(fcenter(X), nested2fmatrix(nested_df, Xc)$X)
  
}, interval = 0.005)
```
- list column operations 2 orders of magnitude slower than direct matrix arithmetic.
- "unnest, do matrix ops, renest" seems slightly faster than "map(<listcolumn>)", but the latter is more general (images, irregular data, ...)
- all in all, timings seem fast enough to not matter all that much

*subsetting*, *interpolating/smoothing*, etc. will behave similarly.

--------------------------------------------------------------------------------

*below is still very much just a scratchpad...*

## Proposal: R package `funtidytastic`

List columns seem not too bad:

- Performance issues are probably negligible for the kind of data we usually have. 
- should be possible to write nice utilities that rely on standardized representation
- ...which should then work for uni- or multivariate, regular or irregular functions, multiple functions per subject, etc...

#### General considerations:

- per-function operations are probably rather easy
- things get more tricky for argument-value wise operations (like computing mean functions etc), but something like `arg_apply` above seems feasible....
- talk to some expert from the `tidyverse`-clique about this to get input
- have to be careful not to re-invent the wheel for basis representation stuff

#### UX & implementation ideas:

- new class `funtibble` for `tibble`s containing a single(!) functional observation 
    - fixed column names `.arg`, `.value`
    - extensible to images, multivariate functions (`.arg1`,`.arg2`, ... ,`.value1`, `.value2`)
    - (indexing based on `argvals`: `X[10]` yields $X(t = 10)$, not 10th evaluation, interpolates automagically if necessary. Interpolation method could be `attribute` of every `funtibble`.)
    - ((make this completely abstract and have child classes that can contain e.g. `fda` objects or other ways to save basis representations etc, with methods for accessing/evaluating for any valid `argval`))
- utilities for `funtibble`s: `integrate`, basis representation stuff (smooth with given basis(& penalty), extract coef for given basis), interpolation for new argvals (with given basis, or just simple linear/cubic/....), descriptive statistics (`mean`, `sd`) that take into account `argvals` where necessary

- new class `tbl_df_fun` inheriting from `tbl_df`
    - `tbl_df_fun` with attribute `funcolumns` to denote which list-columns hold lists of `funtibble`s
    - (maybe more additional attributes, e.g. `argvals`-vector for grid data once as attribute instead of repeated in each cell...? goes against the `funtibble`-idea, though...)
- `f_summarize`/`f_mutate`/`f_transmute`/`f_filter` for `funcolumns` which then perform appropriate ops for functional objects (i.e., they will either be wrappers for `map` or 
perform "unnest-matrix op-nest") -- should implement syntax like
    - `data %>% f_filter(X.value[X.arg == 10] > 0)` (or `X[.arg == 10] > 0`, even?),
      `data %>% f_filter(max(X.value[X.arg < 1]) < 100)` (or `max(X[.arg < 1]) < 100`...?)
    - probably easier to do subsetting more `dplyr` like: `data %>% f_filter(X > 10, select = .arg == 10)`
    
    `data %>% f_mutate(X_truncated = seX[arg > 10])`
    
- `tbl_df_fun`-methods for dplyr-verbs `summarize`, `mutate`, `transmute`, `filter` that dispatch operations on `funcolumns` to `f_summarize`,`f_mutate`,`f_transmute`,`f_filter` (.. probably really hard to get right).


## Other sources:

https://cran.r-project.org/web/packages/Momocs/vignettes/Momocs_speed_dating.html :
tidy shape analysis, seems very well done (supernice PCA viz!)
